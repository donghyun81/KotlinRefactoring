# 3. 코드에서 나는 악취
>코드에서 악취가 난다면 바로 리팩터링을 해야한다 그 악취의 기준을 이 장에서 설명한다.
## 3.1 기이한 이름
> 함수 선언 바꾸기, 변수 이름 바꾸기, 필드 이름 바꾸기로 코드명만으로 무엇을 하는지,뜻하는지 알 수 있게 작성한다.
> 이름을 정하기 어렵고 모호하다면 리팩터링이 덜 되어있을 확률이 높으니 더 근본적으로 해결해보도록 해야한다.

## 3.2 중복 코드
> 한 클래스에 두 메서드가 같은 표현식일 경우
> 문장 슬라이드하기(비슷한 부분을 한곳으로 모으기) -> 함수 추출하기 (양쪽 모두에게 추출된 메서드를 호출하게 변경)
> 같은 부모를 가진 서브 클래스들에 코드 중복일 경우 따로 호출되지 않도록 메서드 올리기로 부모 클래스에 옮긴다.

## 3.3 긴 함수
> 코드를 이해하고 공유하고 선택하기 쉬워진다는 점에서 함수를 짧게 구성하는건 매우 유용하다.
> 주석을 달아야 한다고 생각하는 부분은 모두 함수로 만들어야한다.
> 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다.
> 함수를 묶는 코드는 여러 줄일 수 도 있고 한 줄일 수도 있다.
> 원래 코드보다 길어지더라도 함수로 뽑는다.
> 함수를 짧게 만드는 작업은 함수 추출하기(함수 본문에서 빼내면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 방법)가 99프로 차지한다.
> 임시 변수가 많다면  -> 임시 변수를 질의 함수로 변경, 매개변수 객체(data class) 만들기, 객체(class) 통째로 넘기기로 매개변수의 수를 줄일 수 있다.
> 조건문 -> 조건문 분해하기로 조건마다 실행조건을 함수로 만든다. 같은 조건을 기주능로 나뉘면 조건부 로직을 다형성으로 바꾸기(chapter1에서 했다)
> 반복문 -> 반복문을 함수로 만든다. 추출한 반복문 코드에 적합한 이름을 모르겠으면 두 가지 작업이 섞여 있기 때문일수 있다.
> 과감히 반복문 쪼개기를 적용해서 작업을 분리하자.

## 3.4 긴 매개변수 목록
> 전역 변수를 줄이기 위해 매개변수를 많이 사용하였지만
> 매개변수가 길어지면 그 자체로 코드를 이해하기 힘들어지는 부분이 많다.
> 다른 매개변수에서 값을 얻을수 있으면 매개변수를 질의 함수로 바꾸기 ex) 매개 human:Human 사용 human.info
> 사용중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드는 객체 통째로 넘기기 
> ex) val isMan = human.isMan if(isMan) ... -> if(human.isMan)... 으로 변경
> 매개변수 객체 만들기 ex) data class Human(val info:String,val age:Int ...)
> 플래그 인수 제거하기 : 조건문의 조건에 사용할 변수인 플래그 인수는 함수를 통해 구현 
> 여러개의 함수가 특정 매개변수들의 값을 공통으로 사용할때 여러 함수를 클래스로 묶기를 이용

## 3.5 전역 데이터
> 전역 데이터 캡슐화 할 수 있으면 해라 할 수 없어도 방법을 찾아서 해라

## 3.6 가변 데이터
> 가변 데이터는 골치 아픈 버그를 발생시킬 확률이 높은 데이터다 유용성을 유지하면서 위험도를 낮추는 방법들이 있다.
> 변수 캡슐화하기 : 정해놓은 함수를 거쳐야만 값을 수정할 수 있도록 설정 ex) get,set
> 변수 쪼개기 : 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신할 경우,용도가 여러개일 경우 사용
> ex) : var temp = a+b println(a) temp = a*b println(a) -> val plusAToB = a+b val timesAToB = a*b
> 문장 슬라이드하기, 함수 추출하기 : 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리
> 질의 함수와 변경 함수 분리하기 : 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다.
> 세터 제거하기 : 변경을 안해도 괜찮은 코드라면 최대한 위험도를 줄이기위해 setter를 제거한다.
> 파생 변수를 질의 함수로 바꾸기 : 파생 변수를 get을 통해서 질의 함수로 변경하고 set은 변경한 질의 함수를 받아서 설정한다.
> 여러 함수를 클래스로 묶기,여러 함수를 변환 함수로 묶기: 변수를 갱신하는 코드들의 유효범위를 제한한다.

## 3.7 뒤엉킨 변경
> 뒤엉킨 변경은 단일 책임 원칙(Single Responsilbility Principle)이 제대로 지켜지지 않을 경우 발생
> 단계 쪼개기 : 데이터 구조를 담아 전달하는식으로 분리
> 함수 옮기기 : 적당한 모듈들을 만들어서 관련 함수들을 모은다
> 함수 추출하기 : 처리 과정이 맥락 별로 구분되고 여러 맨락의 일에 관여하는 함수가 있다면 이 방법을 사용후 수행
> 클래스 추출하기 : 모듈이 클래스일 경우 맥락별 분리 방법을 잘 안내해줄수 있기 때문에 사용

## 3.8 산탄총 수술
> 뒤엉킨 변경과 비슷하면서 정반대인 문제
> 코드 변경시 자잘하게 수행해야 하는 클래스가 많을때 발생
> 함수 옮기기,필드 옮기기: 변경할 부분이 코드 전반에 퍼져있다면 변경 대상들을 한 모듈에 묶어두기 위한 방법
> 여러 함수를 클래스로 묶기 : 비슷한 데이터를 다루는 함수가 많다면 적용
> 여러 함수를 변환 함수로 묶기 : 데이터 구조를 변환하거나 보강하는 함수들에게 적용
> 단계 쪼개기 : 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달
> 함수 인라인하기,클래스 인라인하기 : 어설프게 분리된 로직을 인라인 리팩터링으로 하나로 합치기 위한 방법

## 3.9 기능 편애
> 프로그램 모듈화의 목표 : 코드를 여러영역으로 나누고 상호작용을 영역안에서 최대한 영역사이에서는 최소화 시킨다.
> 기능 편애 : 영역안에서 상호작용보다 영역 사이에 상호작용이 더 커질때 생기는 문제
> 함수 옮기기 : 외부 객체의 게터메서드를 여러개 호출하는 경우 함수를 데이터 근처로 옮겨준다.
> 함수 추출하기 : 함수의 일부에서만 기능을 편애할 경우 독립 함수로 빼낸다
> 함수 옮기기 : 추출한 함수를 편애 했던 곳으로 옮겨준다
> 함수 추출하기 : 함수를 여러 조각으로 나눈뒤에 적합한 모듈로 옮기면 더 쉽게 해결 가능하다.
> 사용하는 모듈이 다양하다면 가장 많은 데이터를 포함한 모듈로 옮긴다.

## 3.10 데이터 뭉치
> 데이터 항목들은 뭉쳐주는게 좋아서 뭉친 데이터의 보금자리를 따로 마련해줘야한다.
> 클래스 추출하기 : 데이터 뭉치를 찾아서 하나의 객체로 묶는다
> 매개변수 객체 만들기,객체 통째로 넘기기 : 매개변수의 수를 줄여서 데이터를 뭉친다.
> 데이터 뭉치 판별법 : 값 하나를 삭제할 경우에 그 데이터로 사용할게 없을 경우 객체로 변경해야하는 데이터 뭉치다

## 3.11 기본형 집착
> 시간,날짜와 같은 형식의 사용자 정의가 필요한 타입은 기본형으로 사용하지말고 객체를 만들어서 사용하는걸 매우 권장한다.
> 기본형을 객체로 바꾸기 : 기본형에서 추가로 사용자 정의 함수를 생성할 수 있다.
> 타입 코드를 서브클래스로 바꾸기,조건부 로직을 다형성으로 바꾸기 : 조건부 동작을 제어하는 타입 코드로 쓰였다면 적용
> ex) 조건에 따라 타입에 맞는 객체를 사용할 수 있도록
> 클래스 추출하기, 매개변수 객체 만들기 : 자주 뭉쳐다니는 기본형 그룹도 데이터 뭉치로 기본형이 아닌 객체로 사용하도록 적용

## 3.12 반복되는 switch문
> 조건부 로직을 다형성으로 바꾸기 : 특정 조건일 경우에 실행되는 함수를 다형성으로 구현해야한다.
> ex) when (boolean) { true -> {println("a")} -> when (boolean) { true -> {Println().output(a)}

## 3.13 반복문
> 반복문을 파이프라인으로 바꾸기 : 반복문을 제거 할 수 있다 ex) collection.forEach{} collection.map{}

## 3.14 성의 없는 요소
> 코드의 구조를 프로그램 요소를 이용해서 작업할때 요소의 특징을 살려도이점이 없는 코드가 있을수 있다.
> 예를들어 본문 코드를 그래도 쓰는것 같거나, 메서드가 하나뿐인 클래스(리팩토링으로 구조가 줄어들거나,추가해야하는데 사정상 못했을 경우)
> 함수 인라인하기, 클래스 인라인하기 : 성의 없는 요소를 다른곳에 합쳐서 사용한다.
> 계층 합치기 : 상속을 사용했다면 이걸로 처리하자 (부모 케이스로 이동하는 경우일것이다)

## 3.15 추측성 일반화
> 나중에 필요하겠지 하고 작성한 코드는 지금 사용하는 코드들을 이해하고 구현하는데 방해만 되는 요소일뿐이다.
> 계층합치기 : 하는 일이 거의 없는 추상클래스를 처리한다
> 함수 인라인하기,클래스 인라인하기 : 쓸데없이 위임하는 코드를 처리한다.
> 함수 선언 바꾸기 : 본문에서 사용되지 않는 매개변수를 처리한다.

## 3.16 임시 필드
> 특정 상황에서만 값이 설정되는 필드를 가진 클래스가 있다.
> 하지만 객체를 사용할때는 모든 필드가 설정되어 있다고 생각하는게 보통이다.
> 클래스 추출하기 : 이렇게 덩그러니 떨어진 필드를 추출하여 다른곳으로 옮긴다.
> 함수 옮기기 : 임시 필드들과 관련되 코드를 새 클래스에 몰아넣는다.
> 특이 케이스 추가하기 : 임시 필드들의 유효성 검사뒤에 동작하는 조건부 로직이 있을때 유효하지 않을 경우를 위한 대안 클래스를 만들어서 제거한다.

## 3.17 메세지 체인 
> 메세지 체인이란 한 객체에서 정보를 연쇄적으로 얻는 현상을 말한다 ex) class.student.info.age....
> 위임 숨기기 : 최종 결과 객체가 어떻게 쓰이는지 보고 다양한 연결점을 만드는게 좋다
> 함수 추출하기 -> 함수 옮기기 : 결과 객체를 사용하는 코드 일부를 빼내고 -> 체인을 숨길수 있는지 살펴보자 

## 3.18 중개자
> 팀장에게 일정을 받을때 일정 외에 정보는 전혀 필요없다. 일정을 메세지를 쓰든 비서를 쓰든해서 주는걸 알 필요가 없다.
> 중개자 제거하기 : 해당 정보를 얻을때 중간에 존재하는 메세지,비서등의 정보를 제거해서 팀장과의 연결만 하도록 하자
> 함수 인라인하기 : 위임 메서드를 제거하고 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자

## 3.19 내부자 거래
> 모듈 사이의 거래가 많아지면 결합도가 강해져서 수정이 필요할때 수정해야할 코드가 많아진다.
> 결합도를 줄이고 투명하게 처리해야한다.
> 함수 옮기기, 필드 옮기기 :
> 위임 숨기기 : 여러 모듈이 같은 관심사를 공통 클래스 생성, 위임 숨기기를 이용하여 중간자를 만든다.

## 3.20 거대한 클래스
> 클래스 추출하기 : 필드를 따로 묶어서 클래스를 생성한다. ex) 접두어나 접미어가 같은 필드(depositAmount,depositCurrency)
> 슈퍼클래스 추출하기,타입 코드를 서브클래스로 바꾸기 : 분리한 컴포넌트에 상속 관계가 좋을꺼 같으면 사용
> 클래스 추출하기,슈퍼클래스 추출하기,타입 코드를 서브클래스로 바꾸기 : 특정 기능만 그룹으로 추출할 수 있다면 사용

## 3.21 서로 다른 인터페이스의 대안 클래스들
> 함수 선언 바꾸기 -> 함수 옮기기 -> 슈퍼클래스 추출하기 : 
> 메서드 시그니처 일치 -> 인터페이스가 같아질 땎지 동작을 클래스 안으로  -> 대안 클래스들 중복일 경우 슈퍼클래스로 추출(부모)

## 3.22 데이터 클래스
> 레코드 캡슐화 : public 코드가 있다면 다른 코드에서 깊게 수정하는 경우가 생기기전에 캡슐화를 하자
> 세터 제거하기 : 불변 필드는 세터를 제거해서 숨기자

## 3.23 상속 포기
> 메서드 내리기, 필드 내리기 : 같은 계층의 서브클래스를 만들고 서브 클래스에 물려받지 않을 부모코드를 옮긴다.
> 부모 코드는 공통 코드가 있는게 좋기 때문에 추상 클래스여야만 한다는 주장도 있지만 전부 그렇게 할 필요는 없다
> 하지만 인터페이스는 다르다. 구현을 하지 않는 공통 코드가 있을수 없기 때문에 위 추상클래스처럼 공통으로 구현해야할 코드만 있어야 한다.

## 3.24 주석
> 제일 좋은 코드는 주석이 없어도 쉽게 이해 할 수 있는 코드이다
> 함수 추출하기 : 특정 코드가 하는일을 주석처리하고 싶으면 사용해서 좋은 이름으로 바꿔주자
> 어서션 추가하기 : 시스템 동작의 선행조건을 명시하고 싶다면 사용한다.
> 