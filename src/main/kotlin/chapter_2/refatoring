# 2 리팩터링 원칙

## 2.1 리팩터링 정의
리팩터링(명) : 코드를 이해,수정하기 쉽도록 내부 구조를 변경하는 기법

리팩터링(동) : 겉보기 동작 유지, 여러 가지 리팩터링 기법을 적용해 소프트웨어 재구성

리팩터링은 전과 후가 똑같이 동작해야하는 코드

하지만 밑에 예시와 같은 경우 성능은 변화 될 수 있다

함수 추출하기 -> 콜스택이 달라져서 성능 변화

함수 선언 바꾸기, 함수 옮기기 -> 모듈의 인터페이스 변화


## 2.2 두 개의 모자
기능 추가 모자 : 새 기능이 필요할 경우 기능 모자를 쓰고 기능만 추가

리팩터링 모자 : 리팩터링이 필요할 경우 리팩터링 모자를 쓰고 리팩터링만 구현

## 2.3 리팩터링하는 이유
1. 소프트웨어 설계가 좋아진다. : 
>지속적으로 기능을 추가하다보면 설계 아키텍처가 썩기 쉽다.

>설계를 파악하기도 어렵고 설계가 부패되는 속도에 가속도가 붙기 시작한다.

>설계 아키텍처가 중요한 이유는 : 중복 코드를 줄이고 코드 수정에 용이하여 유지보수가 좋아진다.

2. 소프트웨어 이해하기 쉬워진다. : 
>프로그래밍은 컴퓨터와 대화를 통해 명령을 내리는 작업이다. 
>시키려는 일과 이를 표현한 코드의 차이를 최대한 줄이는게 좋다

>컴퓨터와 대화하는 작업은 기록을 통해 실행된다 그 기록은 다른 사람도 보고 수정 할 수 있어야하고 나도 후에 수정해야한다.
>그래서 수정에 용이하도록 이해하기 쉽도록 작성하는게 좋다.

3. 리팩터링하면 버그를 쉽게 찾을 수 있다. :
> 코드를 이해하기 쉽다는것은 문제를 쉽게 찾을수 있다는 말과 같다.
> 이에 관한 캔트 백의 말 "난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 가진 괜찮은 프로그래머 정도에요."

4. 리팩터링하면 프로그래밍 속도를 높일 수 있다. :
> 리팩터링을 따로 하는 시간 때문에 프로그래밍 속도가 늦어질거라 생각하는 사람이 많을수 있다.

> 하지만 리팩터링을 통해 새로운 기능을 추가하거나 버그를 잡거나 등등 새로운 작업을 하기에 많은 시간을 단축시킬수 있다.

> 처음에는 시간이 더 길어질 수 있겠지만 지속적인 개발에서는 훨씬 더 많은 시간을 줄일 수 있다.

## 2.4 언제 리팩터링해야 할까?
> 나는 거의 한시간 간격으로 리팩터링 한다.

> 3의 법칙이 있다(스트라이크 세번이면 리팩터링)
> 1. 처음에는 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게 되어도 일단 계속 진행한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

1. 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기
> 리팩터링하기 가장 좋은 시점 : 코드베이스에 기능을 추가하기 직전

> 요구사항은 만족하지만 리터럴 값 몇개가 방행되는 함수 일 경우 
> 함수 매개변수화하기를 적용해서 중복코드를 줄일수 있도록한다.

> 그러면 그 함수에 필요한 매개변수를 지정해서 호출하기만 하면된다.
> 이런식으로 중복코드도 줄일 수 있는 작업을 할 수 있도록한다

2. 이해를 위한 리팩터링 : 코드를 이해하기 쉽게 만들기
> 책이나 기사를 읽는것처럼 긴 함수를 나누고 네이밍을 목적에 맞게 수정하는 일을 통해서
> 다음에 해당 코드를 읽으면서 이해하기 쉽도록 만들어야 한다

3. 쓰레기 줍기 리팩터링
> 로직이 쓸데없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 똑같은 함수 여러 개로 작성해놨을 수 있는 더러운 코드가 있다.
> 깨끗하게 정리를 하려고 했어도 보이지 않았던 부분들이 다음에 보이는 경우도 있다.

> 항상 깨끗이 정리할 수 있도록 더러운 코드가 있을경우에 하던일을 메모하고 더러운 코드를 깨끗이하고 넘어가자.

> 캠핑 규칙에서 제안하듯이 내가 방문했을때보다 깔끔하게 정리하고 떠나자.

4. 계획된 리팩터링과 수시로 하는 리팩터링
> 계획을 해서 리팩터링 할 필요도 없이 수시로 하자

5. 오래 걸리는 리팩터링 
> 대규모 리팩터링이 필요할 경우(라이브러리 교채 ,다른 팀과 공유하기 위해 컴포넌트 빼는 작업,의존성 정리 작업)

## 2.5 리팩터링 시 고려할 문제

1. 새 기능 개발 속도 저하 
> 새 기능을 추가 할때 경험을 통해 개발비용과 더 좋은 코드로 바꾸면 좋다고 생각하면 왠만하면 바꾸는게 좋다
> 리팩터링은 코드베이스를 예쁘게 꾸미기 위해 존재하는게 아니다 무조건 개발 비용 절약을 위한 경제적인 부분에 있다.

2. 코드 소유권
> 프로젝트에서 코드 소유권을 느슨하게 하는게 좋다
> 코드를 수정하다보면 다른 팀이나 다른 직원의 코드들과 연계해서 작성하는 부분이 있을때
> 본인이 리팩터링 해서 더 좋은 설계가 될 수 있으면 리팩터링후에 승인을 받는 경우가 훨씬 더 효율적이기 때문이다.

3. 브랜치
> 각각 브랜치 하나로 작업해서 마스터에서 통합하는 경우가 많다
> 장점 : 기능 추가시 버전의 명확성 상승,문제 발생시 이전 상태로 변경 가능
> 단점 : 독립 브랜치 작업기간이 길수록 통합하기 어려워짐(머지는 브랜치에 작업을 마스터에 옮기기한다)
> 통합은 마스터와 브랜치가 각각 양방향 변경이 이루어지는데 다른 사람의 변경사항이 나의 브랜치에 같이 적용된다
> 이럴 경우 내가 수정한 내용과 수정되어온 다른 작업이 겹쳐셔 버그가 발생하고 수정하는데 많은 비용이 들게된다.
> 개선 : 지속적 통합(Continous Integration) , 트렁크 기반 개발 (Trunk-Based-Development)
> CI를 적용하기 위해서는 기능을 잘게 쪼개는 법을 배우고 각 기능을 끌 수 있는 기능 토글을 적용해야 한다.
> eXetrem Programming(켄트 백) : CI와 리팩터링을 합쳐서 만든 기법

4. 테스팅
> 테스트 코드를 작성하는데 비용이 들긴하지만 기능을 추가하거나 리팩터링을 할 경우에 생기는 오류를 발견,수정하는데 너무나 큰 비용이 절감된다.

5. 레거시 코드
> 다른 사람에게 받는 레거시 코드는 끔직하기 그지없다.
> 코드를 파악하고 수정하는데 크게 도움이 되는게 리팩터링이다.
> 하지만 레거시 코드를 리팩터링 하기 위해서는 테스트 코드의 보강이 필수적이다.
> 테스트 코드의 보강을 통해서 리팩터링 하는 책 레거시 코드 활용 전략(에이콘,2018)을 참고한다

6. 데이터 베이스
> 진화형 DB 설계,DB 리팩터링 기법을 통해 데이터 베이스도 리팩터링 할 수 있다.

## 2.6 리팩터링,아키텍처,애그니(YAGNI)
> You Aren't Going to Need It(점진적인,간결한 설계) 초기설계를 고려하지 않는 설계 기법
> 아키텍처와 설계를 개발 프로세스에 녹이는 방식중 하나이며 개발중에 더 깊은 이해가 되었을 때 설계를 수정하고 처리하는쪽이 더 좋다고 생각한다.
> 이러한 경향은 진화형 아키텍처의 원칙이 발전하는 계기가 된다.

## 2.7 리팩터링과 소프트웨어 개발 프로세스
> 테스트 주도 개발(Test-Driven Development) : 자가 테스트 코드와 리팩터링 기법을 묶은 개발 프로세스
> 자가 테스트코드, 지속적 통합, 리팩터링 기법은 서로 강력한 상승효과가 발휘된다.

## 2.8 리팩터링과 성능
> 성능은 더 빠른 하드웨어가 나오리라 믿어 크게 중요치 않게 생각하는 부분도 있다,
> 하지만 성능을 높여서 속도를 빠르게 하는건 이용자들에게 기본적으로 제공해야할 서비스이다.
> 프로그램의 속도는 극히 일부에서 대부분의 시간을 소모하기 때문에 성능을 높이기 위해서는 
> 각 실행부분에 실행부분의 시간을 알 수 있는 api를 통해서 시간을 측정해보고 그 부분을 수정하는게 비용절감에 유리하다.

## 2.9 리팩터링의 유래 
> 

## 2.10 리팩터링 자동화
> 인텔리제이,비주얼 스튜디오등 리팩터링 자동화에 유리한 IDE를 통해서 개발을 할 수 있다.(차차 공부해나가자)
